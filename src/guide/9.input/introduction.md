---
footer: false
---
<table style="display:flex;justify-content:center">
  <tr>
    <td>Bevy版本：</td>
    <td>(0.11)</td>
    <td>(outdated!)</td>
  </tr>
</table>

# 输入处理 {#input-handling}

Bevy支持以下输入：

-   键盘（检测按键何时被按下或释放）

-   字符（用于文本输入；键盘布局由操作系统处理）

-   鼠标（相对运动，滚动）

    -   运动（移动鼠标，不与操作系统光标绑定）
    -   光标（绝对指针位置）
    -   按钮
    -   滚动（鼠标滚轮或触摸板手势）
    -   缩放/旋转触摸手势

-   触摸屏（带多点触控）

-   游戏手柄（控制器，操纵杆）（通过gilrs库）

以下显著的输入设备不被支持：

-   加速计和陀螺仪用于设备倾斜
-   其他传感器，如温度传感器
-   跟踪多点触控板上的单个手指，如触摸屏上
-   麦克风和其他音频输入设备
-   MIDI（乐器），但有一个非官方插件：bevy_midi。

对于大多数输入类型（在有意义的情况下），Bevy提供两种处理方式：

-   通过检查当前状态的资源（输入资源），
-   或通过事件（输入事件）。

有些输入仅作为事件提供。

使用资源检查状态，如`Input`（用于按键或按钮的二进制输入），`Axis`（用于模拟输入），`Touches`（用于触摸屏上的手指逻辑）。这种处理输入的方式非常适合在游戏中实现。在这些场景中，你通常只关心将特定输入映射到游戏中的动作。你可以检查特定按钮/键何时被按下/释放，或它们当前的状态。

事件（输入事件）是一种更低级别、更全面的处理方式。如果你想获取所有来自该类输入设备的活动，而不仅仅是检查特定输入，可以使用它们。

## 输入映射 {#input-mapping}

Bevy目前还没有提供内置的输入映射方式（配置按键绑定等）。你需要自己想办法将输入转换为你的游戏/应用中的逻辑动作。

有一些社区制作的插件可能会对此有所帮助：参见bevy-assets。我个人推荐：Input Manager插件由Leafwing Studios提供。

构建专门针对你的游戏的抽象层可能是个好主意。例如，如果你需要处理玩家移动，你可能想要一个系统来读取输入并将它们转换为你自己的内部"移动意图/动作事件"，然后另一个系统作用于这些内部事件，实际上移动玩家。确保使用明确的系统顺序以避免延迟/帧延迟。

## 运行条件 {#run-conditions}

Bevy还提供运行条件（参见这里的全部内容），你可以将其附加到你的系统上，如果你想要一个特定系统只在某个特定按键或按钮被按下时运行。

通过这种方式，你可以将输入处理作为你的系统的调度/配置的一部分，避免在CPU上运行不必要的代码。

在真实游戏中使用这些并不推荐，因为你必须硬编码按键，这使得无法进行用户可配置的按键绑定。

为了支持可配置的按键绑定，你可以实现你自己的运行条件来检查用户设置中的按键绑定。

如果你正在使用LWIM插件，它也提供了对类似运行条件的基于工作流的支持。