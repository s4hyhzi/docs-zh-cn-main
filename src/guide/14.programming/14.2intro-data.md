---
footer: false
---
<table style="display:flex;justify-content:center">
  <tr>
    <td>Bevy版本：</td>
    <td>(0.12)</td>
    <td>(current)</td>
  </tr>
</table>

# 介绍：您的数据 {#intro-your-data}
这个页面是一个概览，旨在让您对Bevy的工作方式有一个大局观的了解。点击各种链接，您可以被带到专门的页面，在那里您可以了解每个概念的更多信息。

----

正如在[ECS简介](/guide/14.programming/14.1ecs-intro)中提到的，Bevy为您存储所有数据，并允许您轻松灵活地访问您需要的任何内容，无论您在哪里。

ECS的数据结构被称为`World`。这是存储和管理所有数据的地方。对于高级场景，可以有[多个世界](/guide/14.programming/14.5intro-data#entities--components)，每个世界都将表现为它自己独立的ECS。然而，通常情况下，您只需使用Bevy为您的应用程序设置的主World。

您可以用两种不同的方式表示您的数据：[实体/组件](#entities--components)和[资源](#resources)。

## 实体/组件 {#entities--components}
在概念上，您可以通过类比表格的方式来思考，就像在数据库或电子表格中一样。您的不同数据类型（[组件](/guide/14.programming/14.7ec#components)）就像表格的“列”，并且可以有任意多的“行”（[实体](/guide/14.programming/14.7ec#entities)）包含各种组件的值/实例。实体ID就像行号。它是一个整数索引，让您找到特定组件的值。

空的结构体类型的组件（不包含数据）被称为[标记组件](/guide/14.programming/14.7ec#components)。它们作为“标签”很有用，用于识别特定实体或启用某些行为。例如，您可以使用它们来识别玩家实体，标记当前正在追逐玩家的敌人，选择在关卡结束时要销毁的实体等。

这里有一个插图帮助您直观地看到逻辑结构。复选标记显示了每个实体上存在哪些组件类型。空单元格意味着该组件不存在。在这个例子中，我们有一个玩家，一个相机，以及几个敌人。
[`Entity`](https://docs.rs/bevy/0.12.0/bevy/ecs/entity/struct.Entity.html) (ID) | [`Transform`](https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html) | `Player` | `Enemy` | [`Camera`](https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.Camera.html) | `Health` | ... |
| ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | -------- | ------- | ----------------------------------------------------------------------------- | -------- | --- |
| ...                                                                             |                                                                                            |          |         |                                                                               |          |     |
| 107                                                                             | ✓ <br>`<translation>`<br>`<rotation>`<br>`<scale>`                                                   | ✓        |         |                                                                               | ✓ `50.0` |     |
| 108                                                                             | ✓ <br>`<translation>`<br>`<rotation>`<br>`<scale>`                                                   |          | ✓       |                                                                               | ✓ `25.0` |     |
| 109                                                                             | ✓ <br>`<translation>`<br>`<rotation>`<br>`<scale>`                                                   |          |         | ✓ <br>`<camera data>`                                                             |          |     |
| 110                                                                             | ✓ <br>`<translation>`<br>`<rotation>`<br>`<scale>`                                                   |          | ✓       |                                                                               | ✓ `10.0` |     |
| 111                                                                             | ✓ <br>`<translation>`<br>`<rotation>`<br>`<scale>`                                                   |          | ✓       |                                                                               | ✓ `25.0` |     |
| ...

代表事物的这种方式为你提供了灵活性。例如，你可以为你的游戏创建一个`Health`组件。然后你可以有许多代表游戏中不同事物的实体，如玩家、NPC或怪物，所有这些都可以有一个`Health`值（以及其他相关组件）。

典型且明显的模式是使用实体来代表游戏/场景中的“对象”，如相机、玩家、敌人、灯光、道具、UI元素等等。但是，你并不限于这些。ECS是一个通用的数据结构。你可以创建实体和组件来存储任何数据。例如，你可以创建一个实体来存储一堆设置或配置参数，或其他抽象的东西。

使用实体和组件存储的数据是通过[查询](/guide/14.programming/14.9queries)来访问的。例如，如果你想实现一个游戏机制，编写一个[系统](/guide/14.programming/14.5systems)，指定你想访问的组件类型，并做你的事情。你可以遍历所有匹配你的规格的实体，或者访问特定的实体（如果你知道它们的`Entity` ID）。

```rust
#[derive(Component)]
struct Xp(u32);

#[derive(Component)]
struct Health {
    current: u32,
    max: u32,
}

fn level_up(
    // operate on anything that has Xp and Health
    mut query: Query<(&mut Xp, &mut Health)>,
) {
    for (mut xp, mut health) in query.iter_mut() {
        if xp.0 > 1000 {
            xp.0 -= 1000;
            health.max += 25;
            health.current = health.max;
        }
    }
}
```
Bevy可以自动跟踪你的[系统](/src/guide/14.programming/14.5systems)访问了哪些数据，并且可以在多个CPU核心上[并行运行它们](/guide/14.programming/14.16system-order)。这样，你可以无需额外努力就获得多线程处理！

如果你想修改数据结构本身（而不仅仅是访问现有数据），比如创建或移除实体和组件，那就需要特别考虑。Bevy在其他系统可能正在运行时不能改变内存布局。这些操作可以使用[Commands](/guide/14.programming/14.10commands)缓冲/延迟，以便在安全的时候再应用。如果你想立即执行这些操作，也可以通过使用[独占系统](/guide/14.programming/14.13exclusive) [直接访问World](/guide/14.programming/14.14world)。

[Bundles](/guide/14.programming/14.8bundle)作为常见组件集的“模板”，以帮助你在生成新实体时，不会意外遗忘任何东西。

```rust
// Marker for the player
#[derive(Component)]
struct Player;

fn spawn_player(
    // needed for creating/removing data in the ECS World
    mut commands: Commands,
    // needed for loading assets
    asset_server: Res<AssetServer>,
) {
    // create a new entity with whatever components we want
    commands.spawn((
        // give it a marker
        Player,
        // give it health and xp
        Health {
            current: 100,
            max: 125,
        },
        Xp(0),
        // give it a 2D sprite to render on-screen
        // (Bevy's SpriteBundle lets us add everything necessary)
        SpriteBundle {
            texture: asset_server.load("player.png"),
            transform: Transform::from_xyz(25.0, 50.0, 0.0),
            // use the default values for all other components in the bundle
            ..Default::default()
        },
    ));
}
```

## 资源 {#resources}